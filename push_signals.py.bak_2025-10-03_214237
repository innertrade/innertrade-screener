import os, time, json, math, requests

HOST      = os.getenv("HOST", "http://127.0.0.1:8080")
TG_TOKEN  = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT   = os.getenv("TELEGRAM_CHAT_ID")

# –ü–æ—Ä–æ–≥–∏
Z_TH      = float(os.getenv("FORWARD_MIN_Z",      "1.8"))
V_TH      = float(os.getenv("FORWARD_MIN_VOLX",   "1.8"))
OI_TH     = float(os.getenv("FORWARD_MIN_OIZ",    "1.0"))
MIN_VOL24 = float(os.getenv("FORWARD_MIN_VOL24H", "10000000"))
POLL_SEC  = int(  os.getenv("FORWARD_POLL_SEC",   "8"))

# –û–∫–Ω–æ/–∏–Ω—Ç–µ—Ä–≤–∞–ª OI (Bybit v5)
OI_WINDOW   = int(os.getenv("FORWARD_OI_WINDOW",   "48"))
OI_INTERVAL =      os.getenv("FORWARD_OI_INTERVAL","5min")

# –¢–∞–π–º–∞—É—Ç—ã –∏ —Ä–µ—Ç—Ä–∞–∏
TIMEOUT_CONNECT = int(float(os.getenv("FORWARD_TIMEOUT_CONNECT","5")))
TIMEOUT_READ    = int(float(os.getenv("FORWARD_TIMEOUT_READ","30")))
MAX_RETRIES     = int(float(os.getenv("FORWARD_MAX_RETRIES","2")))
RETRY_SLEEP_SEC = float(os.getenv("FORWARD_RETRY_SLEEP","1.0"))

# –ê–Ω—Ç–∏-—Ñ–ª—É–¥
SEND_LIMIT_PER_TICK = int(os.getenv("FORWARD_SEND_LIMIT","5"))

# –ü–æ–ª–∏—Ç–∏–∫–∞ –ø–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–º—É OI
ALLOW_OI_NONE = os.getenv("FORWARD_ALLOW_OI_NONE","false").lower()=="true"

s = requests.Session()
seen = set()  # (symbol, bar_ts) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ

def fmt_money(v):
    try:
        v = float(v or 0)
        if v >= 1_000_000_000: return f"${v/1_000_000_000:.1f}B"
        if v >= 1_000_000:     return f"${v/1_000_000:.1f}M"
        if v >= 1_000:         return f"${v/1_000:.1f}K"
        return f"${v:.0f}"
    except Exception:
        return str(v)

def build_markup(sym: str):
    url_tv    = f"https://www.tradingview.com/chart/?symbol=BYBIT:{sym}.P&interval=5"
    bybit_web = f"https://www.bybit.com/trade/usdt/{sym}"
    return {"inline_keyboard": [[
        {"text": "‚ÜóÔ∏è Bybit",       "url": bybit_web},
        {"text": "‚ÜóÔ∏è TradingView", "url": url_tv},
    ]]}

def pull_signals():
    for _ in range(MAX_RETRIES+1):
        try:
            r = s.get(f"{HOST}/signals", timeout=(TIMEOUT_CONNECT, TIMEOUT_READ))
            return r.json()
        except Exception as e:
            time.sleep(RETRY_SLEEP_SEC)
    raise RuntimeError("signals: retries exceeded")

def fetch_linear_universe():
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç set —Ç–∏–∫–µ—Ä–æ–≤, —É –∫–æ—Ç–æ—Ä—ã—Ö –µ—Å—Ç—å linear perpetual –Ω–∞ Bybit.
    v5/market/instruments-info?category=linear –ø–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω–æ.
    """
    linear = set()
    cursor = None
    for _ in range(20):  # –∑–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ –ø–µ–π–¥–∂–∏–Ω–≥–∞
        params = {"category":"linear"}
        if cursor: params["cursor"] = cursor
        r = s.get("https://api.bybit.com/v5/market/instruments-info",
                  params=params, timeout=(TIMEOUT_CONNECT, TIMEOUT_READ))
        j = r.json()
        lst = (j.get("result",{}) or {}).get("list",[]) or []
        for it in lst:
            sym = it.get("symbol")
            status = (it.get("status") or "").lower()
            if not sym: continue
            if status in ("trading","trading_open","open"):
                linear.add(sym)
        cursor = (j.get("result",{}) or {}).get("nextPageCursor")
        if not cursor: break
    return linear

def fetch_oi_z(sym: str):
    """
    Z-score open interest –ø–æ Bybit v5 open-interest.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç float –∏–ª–∏ None (–æ—à–∏–±–∫–∞/–º–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö).
    """
    for _ in range(MAX_RETRIES+1):
        try:
            r = s.get("https://api.bybit.com/v5/market/open-interest",
                      params={"category":"linear","symbol":sym,"interval":OI_INTERVAL},
                      timeout=(TIMEOUT_CONNECT, TIMEOUT_READ))
            j = r.json()
            arr = (j.get("result",{}) or {}).get("list",[]) or []
            vals = []
            for it in arr:
                v = it.get("openInterest") or it.get("openInterestValue")
                if v is None: continue
                try: vals.append(float(v))
                except: pass
            if len(vals) < 3:
                return None
            series = vals[-OI_WINDOW:] if len(vals) > OI_WINDOW else vals
            mu = sum(series)/len(series)
            var = sum((x-mu)**2 for x in series)/len(series)
            sd = math.sqrt(var) if var>0 else 0.0
            if sd == 0: return 0.0
            return (series[-1]-mu)/sd
        except Exception:
            time.sleep(RETRY_SLEEP_SEC)
    return None

def arrows(z, volx, oi_z):
    def arrow(val, up_th):
        if val >= up_th:  return "‚Üë"
        if val <= -up_th: return "‚Üì"
        return "‚âà0"
    a_p  = arrow(z,   Z_TH)
    a_v  = "‚Üë" if volx >= V_TH else "‚âà0"
    if oi_z is None:
        a_oi = "‚Üë" if ALLOW_OI_NONE else "‚âà0"
    else:
        a_oi = arrow(oi_z, OI_TH)
    return a_p, a_v, a_oi

def classify(a_p, a_v, a_oi):
    # –¢–æ–ª—å–∫–æ –¥–≤–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è:
    if a_p=="‚Üë" and a_v=="‚Üë" and a_oi=="‚Üë": return "LONG","üü¢üìà"
    if a_p=="‚Üì" and a_v=="‚Üë" and a_oi=="‚Üë": return "SHORT","üî¥üìâ"
    return None, None

def main():
    print(f"forwarder start | host={HOST} Z>={Z_TH} Vx>={V_TH} OIz>={OI_TH} v24h>={MIN_VOL24} | OI window={OI_WINDOW} interval={OI_INTERVAL}", flush=True)

    linear = fetch_linear_universe()
    last_linear_reload = time.time()

    while True:
        try:
            # –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ª–∏–Ω–µ–π–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (—Ä–∞–∑ –≤ 30 –º–∏–Ω—É—Ç)
            if time.time() - last_linear_reload > 1800:
                try:
                    linear = fetch_linear_universe()
                except Exception:
                    pass
                last_linear_reload = time.time()

            j = pull_signals()
            send_cnt = 0

            send_cnt = 0
            dbg_left = 20
            send_cnt = 0
            dbg_left = 20
            for sig in j.get("data", []):
                
                dbg_vx = float(sig.get("vol_mult") or 0.0)sym   = str(sig.get("symbol","")).upper()
                bar_ts= sig.get("bar_ts")
                key   = (sym, bar_ts)
                if key in seen:
                    continue

                v24 = float(sig.get("vol24h_usd") or 0.0)
                if v24 < MIN_VOL24:
                    print(f"skip {sym} low v24=${v24:,.0f} < ${MIN_VOL24:,.0f}", flush=True)
                    continue

                # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—ã –±–µ–∑ linear-–ø–µ—Ä–ø–∞ –Ω–∞ Bybit
                if sym not in linear:
                    # print(f"skip {sym} reason=no_linear_contract", flush=True)
                    continue

                z   = float(sig.get("zprice") or 0.0)
                vx  = float(sig.get("vol_mult") or 0.0)

                # –ø–æ–ª—É—á–∞–µ–º OI z —Å –∫–æ—Ä–æ—Ç–∫–∏–º–∏ —Ç–∞–π–º–∞—É—Ç–∞–º–∏
                oi_z = fetch_oi_z(sym)
                # DEBUG eval line
                
                if dbg_left > 0:
                    print(f"eval {sym} z={z:.2f} vx={dbg_vx:.2f} v24={v24:.0f} oi_z={oi_z}", flush=True)
                    dbg_left -= 1

                a_p, a_v, a_oi = arrows(z, vx, oi_z)
                cls, mark = classify(a_p, a_v, a_oi)
                if cls is None:
                    print(f"skip {sym} reason P:{a_p} V:{a_v} OI:{a_oi}", flush=True)
                    continue

                seen.add(key)
                if TG_TOKEN and TG_CHAT and send_cnt < SEND_LIMIT_PER_TICK:
                    legend = f"P:{a_p} V:{a_v} OI:{a_oi}"
                    text = (
                        f"{mark} {sym}\n"
                        f"–¶–µ–Ω–∞ {sig.get('close')}\n"
                        f"{legend} | z={z:+.2f} | vol√ó{vx:.2f} | OI z={('‚Äî' if oi_z is None else f'{oi_z:+.2f}')}\n"
                        f"–û–±–æ—Ä–æ—Ç 24—á ‚âà {fmt_money(v24)}"
                    )
                    try:
                        r = s.post(
                            f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                            json={"chat_id": TG_CHAT, "text": text, "reply_markup": build_markup(sym)},
                            timeout=(TIMEOUT_CONNECT, TIMEOUT_READ),
                        )
                        ok = (r.status_code == 200) and (r.json().get("ok") is True)
                        print(f"sent {sym} {cls} -> http={r.status_code} ok={ok}", flush=True)
                        send_cnt += 1
                    except Exception as e:
                        print(f"send err {sym}: {e}", flush=True)

        except Exception as e:
            print("forward err:", e, flush=True)

        time.sleep(max(1, POLL_SEC))

if __name__ == "__main__":
    main()
