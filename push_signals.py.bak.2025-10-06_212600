#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
InnerTrade ‚Äì Push Signals Forwarder (real OI logic)
"""

import os, time, logging, requests
from typing import Dict, Any, Optional, List

ENGINE_URL = os.getenv("ENGINE_URL", "http://127.0.0.1:8080/signals")
POLL_SEC   = int(os.getenv("POLL_SEC", "8"))

# --- Thresholds ---
Z_MIN   = 1.8
VX_MIN  = 1.6
V24_MIN = 20_000_000  # $20M
OI_MIN = 0.05

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s: %(message)s",
    datefmt="%H:%M:%S"
)

def ok_long(sig: Dict[str, Any]) -> bool:
    """Basic long filter"""
    try:
        z   = float(sig.get("zprice") or 0.0)
        vx  = float(sig.get("vol_mult") or 0.0)
        v24 = float(sig.get("vol24h_usd") or 0.0)
        return (z >= Z_MIN) and (vx >= VX_MIN) and (v24 >= V24_MIN)
    except Exception:
        return False

def is_confirmed(sig: Dict[str, Any]) -> bool:
    """OI confirmation only if oi_z exists and >= OI_MIN"""
    try:
        return float(sig.get("oi_z") or 0.0) >= OI_MIN
    except Exception:
        return False

def send(sig: Dict[str, Any], side: str, oi_z: Optional[float]) -> None:
    import os, requests, time, logging, time, logging, logging
    token = os.getenv("TELEGRAM_BOT_TOKEN"); chat = os.getenv("TELEGRAM_CHAT_ID")
    if not (token and chat):
        logging.warning("send(): TELEGRAM env missing"); return
    sym = str(sig.get("symbol","")).upper()
    z   = float(sig.get("zprice") or 0.0)
    vol = float(sig.get("vol_mult") or 0.0)
    v24 = float(sig.get("vol24h_usd") or 0.0)
    px  = sig.get("close")
    arrow = "‚¨ÜÔ∏è" if z >= 0 else "‚¨áÔ∏è"

    # –∑–∞–≥–æ–ª–æ–≤–æ–∫ –ø–æ —Å—Ç–∞—Ç—É—Å—É
    titles = {
        "pre_long":        f"{arrow} {sym}  (PRE-LONG)",
        "pre_short":       f"{arrow} {sym}  (PRE-SHORT)",
        "long_confirmed":  f"‚úÖ {arrow} {sym}  (LONG CONFIRMED)",
        "short_confirmed": f"‚úÖ {arrow} {sym}  (SHORT CONFIRMED)",
    }
    title = titles.get(side, f"{arrow} {sym}")

    # —Å—Ç—Ä–æ–∫–∞ –ø—Ä–æ OI (–µ—Å–ª–∏ –µ—Å—Ç—å)
    oi_line = ""
    if oi_z is not None:
        try:
            oi_line = "OI z-score: {:+.2f}\n".format(float(oi_z))
        except Exception:
            pass
    text = (
        f"{title}\n"
        f"{'üü¢' if z>=0 else 'üî¥'} Price Œî = {abs(z):.2f}œÉ\n"
        f"üü¢ Volume √ó{vol:.2f}\n"
        f"{oi_line}"
        f"24h Volume ‚âà ${v24:,.0f}\n"
        f"Last price: {px}"
    )
    tv_sym = sym.replace("USDT","USDT.P")  # —á–∞—Å—Ç–æ —Ç–∞–∫ –¥–ª—è perp; —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ –º–µ—Å—Ç—É, –µ—Å–ª–∏ —á—Ç–æ
    tv_url = f"https://www.tradingview.com/chart/?symbol=BYBIT%3A{tv_sym}"
    bybit_fut_url = f"https://www.bybit.com/trade/usdt/{sym}"  # —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ñ—å—é—á–µ—Ä—Å–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ (USDT Perp)

    kb = {
        "inline_keyboard": [[
            {"text":"TradingView","url": tv_url},
            {"text":"Bybit Futures","url": bybit_fut_url}
        ]]
    }

    url = f"https://api.telegram.org/bot{token}/sendMessage"
    data = {"chat_id": chat, "text": text, "reply_markup": kb, "disable_web_page_preview": True}
    try:
        requests.post(url, json=data, timeout=10)
        logging.info(f"sent to TG | {sym} | {side} | z={z:.2f} volx={vol:.2f} oi_z={oi_z}")
    except Exception as e:
        logging.error(f"send(): telegram post error: {e}")


def poll_once():
    try:
        r = requests.get(ENGINE_URL, timeout=10)
        r.raise_for_status()
        data = r.json().get("data", [])
    except Exception as e:
        logging.error(f"engine error: {e}")
        return

    for sig in data:
        try:
            if not ok_long(sig):
                continue
            side = "long_confirmed" if is_confirmed(sig) else "pre_long"
            send(sig, side, sig.get("oi_z"))
        except Exception as e:
            logging.error(f"forward err: {e}")

def main():
    logging.info(
        f"forwarder start | host={ENGINE_URL} "
        f"thresholds: z‚â•{Z_MIN}, vx‚â•{VX_MIN}, v24‚â•{V24_MIN:,}, oi‚â•{OI_MIN}"
    )
    while True:
        poll_once()
        time.sleep(POLL_SEC)

if __name__ == "__main__":
    main()

OK_Z = 1.8
OK_VOLX = 1.6
OK_V24 = 20_000_000

# --- rate limit wrapper ---
# –ù–µ —Å–ª–∞—Ç—å –ø–æ –æ–¥–Ω–æ–π –º–æ–Ω–µ—Ç–µ —á–∞—â–µ, —á–µ–º —Ä–∞–∑ –≤ MIN_INTERVAL_SEC (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 120—Å)
import os, time, logging  # –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –≤—ã—à–µ –Ω–µ –∏–º–ø–æ—Ä—Ç–Ω—É–ª–∏
LAST_SENT = {}
try:
    MIN_INTERVAL = int(os.getenv("MIN_INTERVAL_SEC", "120"))
except Exception:
    MIN_INTERVAL = 120

_send_impl = send
def send(sig: Dict[str, Any], side: str, oi_z: Optional[float]) -> None:
    sym = str(sig.get("symbol","")).upper()
    now = time.time()
    last = LAST_SENT.get(sym, 0)
    if now - last < MIN_INTERVAL:
        try:
            left = int(MIN_INTERVAL - (now - last))
        except Exception:
            left = MIN_INTERVAL
        logging.info(f"skip (cooldown {left}s) {sym}")
        return
    LAST_SENT[sym] = now
    _send_impl(sig, side, oi_z)
# --- end rate limit wrapper ---

# --- anti-burst guard ---
# –û—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –±–∞—Ä—ã, –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞ –æ–¥–∏–Ω poll –∏ –Ω–µ —à–ª—ë–º –¥—É–±–ª–∏–∫–∞—Ç—ã (symbol, bar_ts)
STALE_SEC       = int(os.getenv('FORWARD_STALE_SEC', '300'))     # –Ω–µ —Å–ª–∞—Ç—å, –µ—Å–ª–∏ –±–∞—Ä —Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω
MAX_PER_POLL    = int(os.getenv('FORWARD_MAX_PER_POLL', '10'))   # –º–∞–∫—Å–∏–º—É–º 10 —Å–æ–æ–±—â–µ–Ω–∏–π –∑–∞ –æ–ø—Ä–æ—Å
SEEN_TTL_SEC    = int(os.getenv('FORWARD_SEEN_TTL_SEC','1800'))  # –ø–æ–º–Ω–∏—Ç—å, —á—Ç–æ –±–∞—Ä —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏, 30 –º–∏–Ω

_SEEN = {}  # (sym, bar_ts_ms) -> expires_epoch_sec

def _seen_cleanup(now):
    rm = [k for k,v in _SEEN.items() if v < now]
    for k in rm:
        _SEEN.pop(k, None)

def already_sent(sym, bar_ts_ms, now):
    # True, –µ—Å–ª–∏ —ç—Ç—É –ø–∞—Ä—É (sym,bar_ts) —É–∂–µ —Å–ª–∞–ª–∏ –Ω–µ–¥–∞–≤–Ω–æ; –∏–Ω–∞—á–µ –ø–æ–º–µ—á–∞–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º False.
    key = (str(sym).upper(), int(bar_ts_ms or 0))
    exp = _SEEN.get(key)
    if exp and exp > now:
        return True
    _SEEN[key] = now + SEEN_TTL_SEC
    return False
# --- end anti-burst guard ---

# --- per-symbol cooldown & fingerprint ---
LAST_SENT_AT = {}
LAST_FP = {}
try:
    COOLDOWN = int(os.getenv('MIN_INTERVAL_SEC','120'))
except Exception:
    COOLDOWN = 120

def _fp(it):
    z = float(it.get('zprice') or 0.0)
    vx = float(it.get('vol_mult') or 0.0)
    v24 = float(it.get('vol24h_usd') or 0.0)
    bts = int(it.get('bar_ts') or 0)
    # –ø—Ä–∏–≤—è–∂–µ–º –∫ 5-–º–∏–Ω —Å–≤–µ—á–µ: bar_ts//300000
    cid = (bts//300000) if bts else 0
    return f"{round(z,2)}|{round(vx,2)}|{int(v24//1e6)}|{cid}"

def should_emit(it, now):
    sym = str(it.get('symbol','')).upper()
    fp = _fp(it)
    last_at = LAST_SENT_AT.get(sym, 0)
    last_fp = LAST_FP.get(sym)
    if (now - last_at) < COOLDOWN and fp == last_fp:
        try:
            logging.info(f"skip (dup/cooldown {sym}) fp={fp} left={int(COOLDOWN-(now-last_at))}s")
        except Exception:
            pass
        return False
    LAST_SENT_AT[sym] = now
    LAST_FP[sym] = fp
    return True
# --- end per-symbol cooldown & fingerprint ---
