#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
InnerTrade – Push Signals Forwarder (real OI logic)
"""

import os, time, logging, requests
from typing import Dict, Any, Optional, List

ENGINE_URL = os.getenv("ENGINE_URL", "http://127.0.0.1:8080/signals")
POLL_SEC   = int(os.getenv("POLL_SEC", "8"))

# --- Thresholds ---
Z_MIN   = 1.8
VX_MIN  = 1.6
V24_MIN = 20_000_000  # $20M
OI_MIN = 0.05

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s: %(message)s",
    datefmt="%H:%M:%S"
)

def ok_long(sig: Dict[str, Any]) -> bool:
    """Basic long filter"""
    try:
        z   = float(sig.get("zprice") or 0.0)
        vx  = float(sig.get("vol_mult") or 0.0)
        v24 = float(sig.get("vol24h_usd") or 0.0)
        return (z >= Z_MIN) and (vx >= VX_MIN) and (v24 >= V24_MIN)
    except Exception:
        return False

def is_confirmed(sig: Dict[str, Any]) -> bool:
    """OI confirmation only if oi_z exists and >= OI_MIN"""
    try:
        return float(sig.get("oi_z") or 0.0) >= OI_MIN
    except Exception:
        return False

def send(sig: Dict[str, Any], side: str, oi_z: Optional[float]) -> None:
    import os, requests, logging
    token = os.getenv("TELEGRAM_BOT_TOKEN"); chat = os.getenv("TELEGRAM_CHAT_ID")
    if not (token and chat):
        logging.warning("send(): TELEGRAM env missing"); return
    sym = str(sig.get("symbol","")).upper()
    z   = float(sig.get("zprice") or 0.0)
    vol = float(sig.get("vol_mult") or 0.0)
    v24 = float(sig.get("vol24h_usd") or 0.0)
    px  = sig.get("close")
    arrow = "⬆️" if z >= 0 else "⬇️"

    # заголовок по статусу
    titles = {
        "pre_long":        f"{arrow} {sym}  (PRE-LONG)",
        "pre_short":       f"{arrow} {sym}  (PRE-SHORT)",
        "long_confirmed":  f"✅ {arrow} {sym}  (LONG CONFIRMED)",
        "short_confirmed": f"✅ {arrow} {sym}  (SHORT CONFIRMED)",
    }
    title = titles.get(side, f"{arrow} {sym}")

    # строка про OI (если есть)
    oi_line = ""
    if oi_z is not None:
        try:
            oi_line = "OI z-score: {:+.2f}\n".format(float(oi_z))
        except Exception:
            pass
    text = (
        f"{title}\n"
        f"{'🟢' if z>=0 else '🔴'} Price Δ = {abs(z):.2f}σ\n"
        f"🟢 Volume ×{vol:.2f}\n"
        f"{oi_line}"
        f"24h Volume ≈ ${v24:,.0f}\n"
        f"Last price: {px}"
    )
    tv_sym = sym.replace("USDT","USDT.P")  # часто так для perp; скорректируем по месту, если что
    tv_url = f"https://www.tradingview.com/chart/?symbol=BYBIT%3A{tv_sym}"
    bybit_fut_url = f"https://www.bybit.com/trade/usdt/{sym}"  # страница фьючерсного контракта (USDT Perp)

    kb = {
        "inline_keyboard": [[
            {"text":"TradingView","url": tv_url},
            {"text":"Bybit Futures","url": bybit_fut_url}
        ]]
    }

    url = f"https://api.telegram.org/bot{token}/sendMessage"
    data = {"chat_id": chat, "text": text, "reply_markup": kb, "disable_web_page_preview": True}
    try:
        requests.post(url, json=data, timeout=10)
        logging.info(f"sent to TG | {sym} | {side} | z={z:.2f} volx={vol:.2f} oi_z={oi_z}")
    except Exception as e:
        logging.error(f"send(): telegram post error: {e}")


def poll_once():
    try:
        r = requests.get(ENGINE_URL, timeout=10)
        r.raise_for_status()
        data = r.json().get("data", [])
    except Exception as e:
        logging.error(f"engine error: {e}")
        return

    for sig in data:
        try:
            if not ok_long(sig):
                continue
            side = "long_confirmed" if is_confirmed(sig) else "pre_long"
            send(sig, side, sig.get("oi_z"))
        except Exception as e:
            logging.error(f"forward err: {e}")

def main():
    logging.info(
        f"forwarder start | host={ENGINE_URL} "
        f"thresholds: z≥{Z_MIN}, vx≥{VX_MIN}, v24≥{V24_MIN:,}, oi≥{OI_MIN}"
    )
    while True:
        poll_once()
        time.sleep(POLL_SEC)

if __name__ == "__main__":
    main()

OK_Z = 1.8
OK_VOLX = 1.6
OK_V24 = 20_000_000

# --- rate limit wrapper ---
# Не слать по одной монете чаще, чем раз в MIN_INTERVAL_SEC (по умолчанию 120с)
import os, time, logging  # на случай, если выше не импортнули
LAST_SENT = {}
try:
    MIN_INTERVAL = int(os.getenv("MIN_INTERVAL_SEC", "120"))
except Exception:
    MIN_INTERVAL = 120

_send_impl = send
def send(sig: Dict[str, Any], side: str, oi_z: Optional[float]) -> None:
    sym = str(sig.get("symbol","")).upper()
    now = time.time()
    last = LAST_SENT.get(sym, 0)
    if now - last < MIN_INTERVAL:
        try:
            left = int(MIN_INTERVAL - (now - last))
        except Exception:
            left = MIN_INTERVAL
        logging.info(f"skip (cooldown {left}s) {sym}")
        return
    LAST_SENT[sym] = now
    _send_impl(sig, side, oi_z)
# --- end rate limit wrapper ---
