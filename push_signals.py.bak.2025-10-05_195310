import os, time, json, requests
from datetime import datetime

HOST      = os.getenv("HOST", "http://127.0.0.1:8080")
TG_TOKEN  = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT   = os.getenv("TELEGRAM_CHAT_ID")

# Пороги (по умолчанию — поток не душим: OI не обязателен, MIN_VOL24H=0)
MIN_Z        = float(os.getenv("FORWARD_MIN_Z",       "1.8"))
MIN_VOLX     = float(os.getenv("FORWARD_MIN_VOLX",    "1.6"))
MIN_VOL24H   = float(os.getenv("FORWARD_MIN_VOL24H",  "0"))
MIN_OI_Z     = float(os.getenv("FORWARD_MIN_OIZ",     "0.0"))
REQUIRE_OI   = os.getenv("FORWARD_REQUIRE_OI",        "false").lower() in ("1","true","yes")
POLL_SEC     = int(os.getenv("FORWARD_POLL_SEC",      "8"))

# OI окно/интервал
OI_WINDOW    = int(os.getenv("FORWARD_OI_WINDOW",     "48"))
OI_INTERVAL  = os.getenv("FORWARD_OI_INTERVAL",       "5min")

# HTTP таймауты/ретраи
TIMEOUT_CONNECT = int(float(os.getenv("FORWARD_TIMEOUT_CONNECT","5")))
TIMEOUT_READ    = int(float(os.getenv("FORWARD_TIMEOUT_READ","30")))
MAX_RETRIES     = int(float(os.getenv("FORWARD_MAX_RETRIES","3")))
RETRY_SLEEP_SEC = float(os.getenv("FORWARD_RETRY_SLEEP","1.0"))

s    = requests.Session()
seen = set()

def fmt_money(x):
    try:
        v = float(x or 0)
        if v >= 1_000_000_000: return f"${v/1_000_000_000:.1f}B"
        if v >= 1_000_000:     return f"${v/1_000_000:.1f}M"
        if v >= 1_000:         return f"${v/1_000:.1f}K"
        return f"${v:.0f}"
    except Exception:
        return str(x)

def build_markup(sym: str):
    base = sym[:-4] if sym.upper().endswith("USDT") else sym
    bybit_web = f"https://www.bybit.com/trade/usdt/{sym.upper()}"
    tv_5m     = f"https://www.tradingview.com/chart/?symbol=BYBIT:{base.upper()}.P&interval=5"
    return {"inline_keyboard":[
        [{"text":"↗️ Open on Bybit","url":bybit_web},
         {"text":"↗️ TradingView (5m)","url":tv_5m}]
    ]}

def pull_signals_json():
    last = None
    for _ in range(MAX_RETRIES):
        try:
            r = s.get(f"{HOST}/signals", timeout=(TIMEOUT_CONNECT, TIMEOUT_READ))
            r.raise_for_status()
            return r.json()
        except Exception as e:
            last = e
            time.sleep(RETRY_SLEEP_SEC)
    raise RuntimeError(f"/signals retries exceeded: {last}")

def fetch_oi_z(sym: str):
    try:
        r = s.get(
            "https://api.bybit.com/v5/market/open-interest",
            params={"category":"linear","symbol":sym,"interval":OI_INTERVAL},
            timeout=(TIMEOUT_CONNECT, TIMEOUT_READ),
        )
        j = r.json()
        arr = (j.get("result",{}) or {}).get("list",[]) or []
        vals = []
        for it in arr:
            v = it.get("openInterestValue") or it.get("openInterest")
            if v is None: continue
            try: vals.append(float(v))
            except: pass
        if len(vals) < max(10, OI_WINDOW//2):
            return None
        series = vals[-OI_WINDOW:]
        mu  = sum(series)/len(series)
        var = sum((x-mu)*(x-mu) for x in series)/len(series)
        sd  = var**0.5
        return 0.0 if sd==0 else (series[-1]-mu)/sd
    except Exception:
        return None

def classify(zprice: float, volx: float, v24: float, oi_z):
    """
    Возвращаем одно из:
      - "pre_long" / "pre_short"      — базовые пороги выполнены, OI нет/ниже порога
      - "long_confirmed" / "short_confirmed" — базовые + OI_z >= MIN_OI_Z
      - None                          — не проходит базовые пороги
    """
    base_ok = (abs(zprice) >= MIN_Z) and (volx >= MIN_VOLX) and (v24 >= MIN_VOL24H)
    if not base_ok:
        return None
    direction = "long" if zprice > 0 else "short"
    if oi_z is None or oi_z < MIN_OI_Z:
        return f"pre_{direction}"
    return f"{direction}_confirmed"
def _format_msg(sig, side: str, oi_z, min_oi: float):
    sym = str(sig.get("symbol","")).upper()
    z   = float(sig.get("zprice") or 0.0)
    volx= float(sig.get("vol_mult") or 0.0)
    v24 = float(sig.get("vol24h_usd") or 0.0)
    px  = sig.get("close")

    # Пытаемся взять проценты изменения цены, если движок их отдает
    pct = None
    for k in ("price_change_pct","price_change_60s_pct","price_change_5m_pct"):
        if sig.get(k) is not None:
            try:
                pct = float(sig[k])* (100.0 if abs(sig[k])<2 else 1.0)
            except:
                pct = None
            break

    def fmt_money(x):
        try:
            v=float(x or 0)
            if v>=1_000_000_000: return f"${v/1_000_000_000:.1f}B"
            if v>=1_000_000:     return f"${v/1_000_000:.1f}M"
            if v>=1_000:         return f"${v/1_000:.1f}K"
            return f"${v:.0f}"
        except: return str(x)

    up = z >= 0
    arrow = "⬆️" if up else "⬇️"

    # Статус/заголовок
    if side in ("long","short"):
        hdr = f"✅ {arrow} {sym}  ({'LONG' if up else 'SHORT'} CONFIRMED)"
        oi_line = f"🟢 OI Δ={oi_z:+.2f}" if oi_z is not None else "🟢 OI Δ=—"
    else:
        hdr = f"{arrow} {sym}  ({'PRE-LONG' if up else 'PRE-SHORT'})"
        oi_line = "⏳ Awaiting OI confirmation"

    # Линия цены
    if pct is not None:
        price_line = f"🟢 Price Δ={pct:+.2f}%"
    else:
        price_line = f"🟢 Price Δ={z:+.2g}σ"

    text = _format_msg(sig, side, oi_z, float(os.getenv('FORWARD_MIN_OIZ','0') or 0))
    if TG_TOKEN and TG_CHAT:
        try:
            r = s.post(
                f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                json={"chat_id": TG_CHAT, "text": text, "reply_markup": build_markup(sym), "disable_web_page_preview": True},
                timeout=(TIMEOUT_CONNECT, TIMEOUT_READ),
            )
            if r.status_code != 200:
                print(f"send error {sym}: {r.status_code} {r.text[:200]}", flush=True)
        except Exception as e:
            print("send exception:", e, flush=True)

def main():
    print(
        f"forwarder start | host={HOST} Z>={MIN_Z} Vx>={MIN_VOLX} v24h>={MIN_VOL24H} | "
        f"OI {'REQUIRED' if REQUIRE_OI else 'optional'} min_z={MIN_OI_Z} | "
        f"OI window={OI_WINDOW} interval={OI_INTERVAL}",
        flush=True
    )
    while True:
        try:
            j = pull_signals_json()
            for sig in j.get("data", []):
                key = (sig.get("symbol"), sig.get("bar_ts"))
                if key in seen: 
                    continue
                seen.add(key)
                z   = float(sig.get("zprice") or 0.0)
                vol = float(sig.get("vol_mult") or 0.0)
                v24 = float(sig.get("vol24h_usd") or 0.0)
                sym = str(sig.get("symbol","")).upper()
                oi_z = fetch_oi_z(sym) if (REQUIRE_OI or MIN_OI_Z>0.0) else None
                side = classify(z, vol, v24, oi_z)
                if side is None:
                    continue
                send(sig, side, oi_z)
        except Exception as e:
            print("forward err:", e, flush=True)
        time.sleep(max(1, POLL_SEC))

if __name__ == "__main__":
    main()

def make_kb(sym: str):
    base = sym[:-4] if sym.endswith('USDT') else sym
    bybit = f'https://www.bybit.com/en/trade/spot/{base}/USDT'
    tv    = f'https://www.tradingview.com/chart/?symbol=BYBIT:{base}USDT.P&interval=5'
    return {'inline_keyboard': [[
        {'text':'Bybit','url': bybit},
        {'text':'TradingView','url': tv}
    ]]}

def send(sig, side, oi_z):
    import os, requests
    TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TG_CHAT  = os.getenv("TELEGRAM_CHAT_ID")
    if not (TG_TOKEN and TG_CHAT):
        return

    sym = str(sig.get("symbol","")).upper()
    z   = float(sig.get("zprice") or 0.0)
    vol = float(sig.get("vol_mult") or 0.0)
    px  = sig.get("close")
    v24 = float(sig.get("vol24h_usd") or 0.0)

    def fmt_money(x):
        v = float(x or 0)
        if v >= 1_000_000_000: return f"${v/1_000_000_000:.1f}B"
        if v >= 1_000_000:     return f"${v/1_000_000:.1f}M"
        if v >= 1_000:         return f"${v/1_000:.1f}K"
        return f"${v:.0f}"

    up   = z >= 0
    arrow = "⬆️" if up else "⬇️"
    price_line = f"{'🟢' if up else '🔴'} Price Δ={abs(z):+.2f}σ"
    vol_line   = f"🟢 Volume ×{vol:.2f}"

    if side == "pre_long":
        title = f"{arrow} {sym}  (PRE-LONG)"
        text  = f"{title}\n{price_line}\n{vol_line}\n⏳ Awaiting OI confirmation\n24h Volume ≈ {fmt_money(v24)}"
    elif side == "pre_short":
        title = f"{arrow} {sym}  (PRE-SHORT)"
        text  = f"{title}\n{price_line}\n{vol_line}\n⏳ Awaiting OI confirmation\n24h Volume ≈ {fmt_money(v24)}"
    elif side == "long_confirmed":
        title = f"✅ {arrow} {sym}  (LONG CONFIRMED)"
        oi_line = f"🟢 OI Δ={oi_z:+.2f}σ" if oi_z is not None else "🟡 OI Δ=—"
        text  = f"{title}\n{price_line}\n{vol_line}\n{oi_line}\n24h Volume ≈ {fmt_money(v24)}"
    elif side == "short_confirmed":
        title = f"✅ {arrow} {sym}  (SHORT CONFIRMED)"
        oi_line = f"🔴 OI Δ={oi_z:+.2f}σ" if oi_z is not None else "🟡 OI Δ=—"
        text  = f"{title}\n{price_line}\n{vol_line}\n{oi_line}\n24h Volume ≈ {fmt_money(v24)}"
    else:
        return

    try:
        r = requests.post(
            f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
            json={"chat_id": TG_CHAT, "text": text, "reply_markup": make_kb(sym), "disable_web_page_preview": True},
            timeout=(5, 30),
        )
        if r.status_code != 200:
            print(f"send error {sym}: {r.status_code} {r.text[:180]}", flush=True)
    except Exception as e:
        print("send exception:", e, flush=True)
