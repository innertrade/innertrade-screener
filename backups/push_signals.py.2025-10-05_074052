import os, time, math, requests

HOST   = os.getenv("HOST", "http://127.0.0.1:8080")
TOKEN  = os.getenv("TELEGRAM_BOT_TOKEN")
CHAT   = os.getenv("TELEGRAM_CHAT_ID")

Z_TH      = float(os.getenv("FORWARD_MIN_Z",      "1.8"))
Z_SHORT = float(os.getenv("FORWARD_MIN_Z_SHORT", os.getenv("FORWARD_MIN_Z","1.8")))
V_TH      = float(os.getenv("FORWARD_MIN_VOLX",   "1.8"))
OI_TH     = float(os.getenv("FORWARD_MIN_OIZ",    "0.8"))
MIN_VOL24 = float(os.getenv("FORWARD_MIN_VOL24H", "10000000"))
CONS_N    = int(os.getenv("FORWARD_CONSENSUS_BARS","2"))

OI_WINDOW   = int(os.getenv("FORWARD_OI_WINDOW",   "24"))
OI_INTERVAL =      os.getenv("FORWARD_OI_INTERVAL","15min")
ALLOW_OI_NONE = os.getenv("FORWARD_ALLOW_OI_NONE","false").lower()=="true"

POLL_SEC = int(os.getenv("FORWARD_POLL_SEC","8"))
T_CONN   = int(float(os.getenv("FORWARD_TIMEOUT_CONNECT","5")))
T_READ   = int(float(os.getenv("FORWARD_TIMEOUT_READ","30")))
RETRIES  = int(float(os.getenv("FORWARD_MAX_RETRIES","2")))
SLEEP_R  = float(os.getenv("FORWARD_RETRY_SLEEP","1.0"))
SEND_LIM = int(os.getenv("FORWARD_SEND_LIMIT","3"))
COOLDOWN = int(os.getenv("FORWARD_COOLDOWN_MIN","30"))*60

s = requests.Session()

# --- Bybit helpers ---
linear_cache = {}
def bybit_norm_symbol(sym: str) -> str:
    # –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º SHIB1000USDT -> 1000SHIBUSDT, PEPE1000USDT -> 1000PEPEUSDT –∏ —Ç.–ø.
    m = re.match(r'^([A-Z0-9]+?)(\d{3,5})USDT$', sym)
    if m:
        base, mult = m.group(1), m.group(2)
        return f"{mult}{base}USDT"
    return sym

def has_linear(sym: str) -> bool:
    sym = bybit_norm_symbol(sym)
    v = linear_cache.get(sym)
    if v is not None:
        return v
    try:
        r = s.get('https://api.bybit.com/v5/market/instruments-info',
                 params={'category':'linear','symbol': sym}, timeout=(3,6))
        arr = (r.json().get('result',{}) or {}).get('list',[]) or []
        ok = len(arr) > 0
    except Exception:
        ok = False
    linear_cache[sym] = ok
    return ok

# ---- —Ç–æ–ª—å–∫–æ –ª–∏–Ω–µ–π–Ω—ã–µ –ø–µ—Ä–ø—ã Bybit (—Å –∫–µ—à–µ–º) ----
linear_cache = {}
def has_linear(sym:str)->bool:
    v = linear_cache.get(sym)
    if v is not None: return v
    try:
        r = s.get("https://api.bybit.com/v5/market/instruments-info",
                  params={"category":"linear","symbol":sym},
                  timeout=(T_CONN, T_READ))
        arr = (r.json().get("result",{}) or {}).get("list",[]) or []
        ok = len(arr) > 0
    except Exception:
        ok = False
    linear_cache[sym] = ok
    return ok

# ---- —Ç–µ—Ö–Ω–∏—á–∫–∞ ----
seen_bars    = set()     # (sym, bar_ts): —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –±–∞—Ä
last_sent_at = {}        # sym -> last unix ts (cooldown)

def fmt_money(x):
    try:
        v = float(x or 0)
        if v >= 1_000_000_000: return f"${v/1_000_000_000:.1f}B"
        if v >= 1_000_000:     return f"${v/1_000_000:.1f}M"
        if v >= 1_000:         return f"${v/1_000:.1f}K"
        return f"${v:.0f}"
    except Exception:
        return str(x)

def markup(sym:str):
    return {"inline_keyboard":[[
        {"text":"‚ÜóÔ∏è Bybit",       "url": f"https://www.bybit.com/trade/usdt/{sym}"},
        {"text":"‚ÜóÔ∏è TradingView", "url": f"https://www.tradingview.com/chart/?symbol=BYBIT:{sym}.P&interval=5"},
    ]]}

def fetch_oi_z(sym:str):
    """–í–µ—Ä–Ω—ë—Ç z-score OI –ø–æ Bybit v5 (linear). None –ø—Ä–∏ –æ—à–∏–±–∫–µ/–º–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö."""
    try:
        r = s.get(
            "https://api.bybit.com/v5/market/open-interest",
            params={"category":"linear","symbol":sym,"intervalTime":OI_INTERVAL},
            timeout=(T_CONN, T_READ),
        )
        j = r.json()
        arr = (j.get("result", {}) or {}).get("list", []) or []
        vals = []
        for it in arr:
            v = it.get("openInterest") or it.get("openInterestValue")
            if v is None:
                continue
            try:
                vals.append(float(v))
            except Exception:
                pass
        if len(vals) < 3:
            return None
        series = vals[-OI_WINDOW:] if len(vals) > OI_WINDOW else vals
        mu = sum(series)/len(series)
        var = sum((x-mu)**2 for x in series)/len(series)
        sd = var**0.5 if var > 0 else 0.0
        return 0.0 if sd == 0 else (series[-1]-mu)/sd
    except Exception:
        return None

def arrows(z, volx, oi_z):
    """–í–µ—Ä–Ω—ë—Ç —Å—Ç—Ä–µ–ª–∫–∏ ‚Üë/‚âà0/‚Üì –¥–ª—è —Ü–µ–Ω—ã, –æ–±—ä—ë–º–∞, OI."""
    def arrow(val, up_th, dn_th=None):
        if dn_th is None:
            dn_th = -up_th
        if val >= up_th:
            return "‚Üë"
        if val <= dn_th:
            return "‚Üì"
        return "‚âà0"
    # —Ü–µ–Ω–∞: –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–µ –ø–æ—Ä–æ–≥–∏ (–≤–Ω–∏–∑ –∏—Å–ø–æ–ª—å–∑—É–µ–º Z_SHORT)
    a_p = arrow(z, Z_TH, -Z_SHORT)
    # –æ–±—ä—ë–º: –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç —Ä–æ—Å—Ç; –ø–∞–¥–µ–Ω–∏–µ —Å—á–∏—Ç–∞–µ–º –Ω–µ-—Å–∏–≥–Ω–∞–ª–æ–º (‚âà0)
    a_v = arrow(volx, V_TH)
    # OI: None —Ç—Ä–∞–∫—Ç—É–µ–º –∫–∞–∫ ¬´‚âà0¬ª, –Ω–µ ¬´–≤–≤–µ—Ä—Ö¬ª
    if oi_z is None:
        a_oi = "‚âà0"
    else:
        a_oi = arrow(oi_z, OI_TH)
    return a_p, a_v, a_oi

    def arrow(val, up_th, dn_th=None):
        if dn_th is None: dn_th = -up_th
        if val >= up_th:  return '‚Üë'
        if val <= dn_th:  return '‚Üì'
        return '‚âà0'
    a_p = arrow(z, Z_TH, -Z_SHORT)
    a_v = arrow(volx,V_TH)
    # OI: None -> ‚Üë –µ—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ, –∏–Ω–∞—á–µ ‚âà0
    ALLOW = os.getenv('FORWARD_ALLOW_OI_NONE','false').lower()=='true'
    if oi_z is None:
        a_oi = '‚Üë' if ALLOW else '‚âà0'
    else:
        a_oi = arrow(oi_z, OI_TH)
    return a_p, a_v, a_oi
def classify(a_p, a_v, a_oi):
    """
    –ü—Ä–∞–≤–∏–ª–∞:
      LONG:  Price‚Üë AND Volume‚Üë AND OI‚Üë
      SHORT: Price‚Üì AND Volume‚Üë AND OI‚Üë
    """
    # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø–µ—Ä–µ–¥ —Ä–µ—à–µ–Ω–∏–µ–º
    # print(f"DEBUG class=> P:{a_p} V:{a_v} OI:{a_oi}")
    if a_p == "‚Üë" and a_v == "‚Üë" and a_oi == "‚Üë":
        return "LONG", "üü¢"
    if a_p == "‚Üì" and a_v == "‚Üë" and a_oi == "‚Üë":
        return "SHORT", "üî¥"
    return None, "‚ö™"
def pull_signals():
    for _ in range(1+RETRIES):
        try:
            r = s.get(f"{HOST}/signals", timeout=(T_CONN, T_READ))
            return r.json()
        except Exception:
            time.sleep(SLEEP_R)
    raise RuntimeError("signals: retries exceeded")

print(f"forwarder start | host={HOST} Z>={Z_TH} Vx>={V_TH} OIz>={OI_TH} v24h>={MIN_VOL24:.1f} | OI window={OI_WINDOW} interval={OI_INTERVAL} | consensus={CONS_N}x5m", flush=True)

while True:
    send_cnt = 0
    try:
        j = pull_signals()
        data = j.get("data", [])
        # —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –±–∞—Ä–∞, —á—Ç–æ–±—ã –Ω–µ —Å–∫–∞–∫–∞—Ç—å
        data.sort(key=lambda d: d.get("bar_ts", 0))

        # —Å–∫–æ–ª—å–∑—è—â–∏–µ –æ–∫–Ω–∞ –Ω–∞ –∫–æ–Ω—Å–µ–Ω—Å—É—Å –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É
        streak = {}  # sym -> –ø–æ–¥—Ä—è–¥ –ø—Ä–æ—à–µ–¥—à–∏—Ö –ø–æ—Ä–æ–≥–∏ 5m-–±–∞—Ä–æ–≤

        for sig in data:
            sym    = str(sig.get("symbol","")).upper()
            bar_ts = sig.get("bar_ts")
            key    = (sym, bar_ts)
            if key in seen_bars:
                continue

            # —Ç–æ–ª—å–∫–æ –ª–∏–Ω–µ–π–Ω—ã–µ –ø–µ—Ä–ø—ã
            if not has_linear(sym):
                continue

            # –ø–æ—Ä–æ–≥–∏ –ø–æ —Ü–µ–Ω–µ/–æ–±—ä—ë–º—É/–ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ —è–¥—Ä–∞
            z   = float(sig.get("zprice") or 0.0)
            volx= float(sig.get("vol_mult") or 0.0)
            v24 = float(sig.get("vol24h_usd") or 0.0)
            if v24 < MIN_VOL24 or abs(z) < min(Z_TH, Z_SHORT) or volx < V_TH:
                continue

            # –∫–æ–Ω—Å–µ–Ω—Å—É—Å: N –ø–æ–¥—Ä—è–¥ 5m-–±–∞—Ä–æ–≤
            streak[sym] = streak.get(sym, 0) + 1
            if streak[sym] < CONS_N:
                continue

            # —Å—Ç—Ä–æ–≥–∏–π OI
            oi_z = fetch_oi_z(sym)
            if (oi_z is None) and (not ALLOW_OI_NONE):
                # –ø—Ä–æ–ø—É—Å–∫: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ OI –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
                continue

            # –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è
            a_p, a_v, a_oi = arrows(z, volx, oi_z)
            print(f"DEBUG eval=> {sym} z={z:.2f} vx={volx:.2f} oi_z={oi_z}  -> P:{a_p} V:{a_v} OI:{a_oi}", flush=True)
            cls, mark = classify(a_p, a_v, a_oi)
            # --- PRE stage (two-step) ---
            if PRE_ENABLED and not cls:
                pre_side = "LONG" if (a_p=="‚Üë" and a_v=="‚Üë") else ("SHORT" if (a_p=="‚Üì" and a_v=="‚Üë") else None)
                ok_oi = (a_oi=="‚âà0") if PRE_REQUIRE_OI_FLAT else (a_oi!="‚Üë")
                if pre_side and ok_oi:
                    now = int(time.time())
                    lp = last_pre_at.get(sym, 0)
                    if now - lp >= PRE_COOLDOWN:
                        pre_cache[sym] = {"created_at": now, "side": pre_side, "z": z, "volx": volx, "v24": v24}
                        last_pre_at[sym] = now
                        pre_icon = "‚¨áÔ∏è" if pre_side=="SHORT" else "‚¨ÜÔ∏è"
                        pre_text = (
                            f"{pre_icon} {sym}  (PRE-{pre_side})\n"
                            f"üü¢ Price Œî={z:+.2f}\n"\
                            f"üü¢ Volume √ó{volx:.2f}\n"\
                            f"‚è≥  Awaiting OI confirmation\n"\
                            f"24h Volume ‚âà {fmt_money(v24)}"
                        )
                        print(f"DEBUG PRE=> {sym} side={pre_side} z={z:+.2f} volx={volx:.2f} a_oi={a_oi}", flush=True)
                        if TOKEN and CHAT:
                            try:
                                s.post(
                                    f"https://api.telegram.org/bot{TOKEN}/sendMessage",
                                    json={"chat_id": CHAT, "text": pre_text, "disable_web_page_preview": True},
                                    timeout=(T_CONN, T_READ)
                                )
                            except Exception:
                                pass

            print(f"DEBUG class=> {sym} P:{a_p} V:{a_v} OI:{a_oi} -> cls={cls} mark={mark}", flush=True)
            if not cls:
                continue

            # dedupe + cooldown
            now = int(time.time())
            last = last_sent_at.get(sym, 0)
            if last and (now - last < COOLDOWN):
                continue
            if send_cnt >= SEND_LIM:
                continue

            seen_bars.add(key)
            last_sent_at[sym] = now

            # —Ç–µ–∫—Å—Ç
            oistr = "‚Äî" if oi_z is None else f"{oi_z:+.2f}"
            text = (
                f"{mark} {sym}  ({cls})\n"
                f"z={z:+.2f} | vol√ó{volx:.2f} | OI z={oistr}\n"
                f"24h volume ‚âà {fmt_money(v24)}"
            )

            if TOKEN and CHAT:
                r = s.post(f"https://api.telegram.org/bot{TOKEN}/sendMessage",
                           json={"chat_id": CHAT, "text": text, "reply_markup": markup(sym),
                                         try:
            print(f"DEBUG PRE TG status => {{resp.status_code}}", flush=True)
        except Exception:
            pass
"disable_web_page_preview": True},
                           timeout=(T_CONN, T_READ))
                try:
                    ok = (r.status_code==200) and (r.json().get("ok") is True)
                except Exception:
                    ok = False
                print(f"sent {sym} {cls} -> http={r.status_code} ok={ok}", flush=True)
                send_cnt += 1

    except Exception as e:
        print("forward err:", e, flush=True)

    time.sleep(max(1, POLL_SEC))
