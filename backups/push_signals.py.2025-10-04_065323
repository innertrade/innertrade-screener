import os, time, math, requests

HOST   = os.getenv("HOST", "http://127.0.0.1:8080")
TOKEN  = os.getenv("TELEGRAM_BOT_TOKEN")
CHAT   = os.getenv("TELEGRAM_CHAT_ID")

# –ü–æ—Ä–æ–≥–∏
Z_TH      = float(os.getenv("FORWARD_MIN_Z",      "1.8"))
V_TH      = float(os.getenv("FORWARD_MIN_VOLX",   "1.8"))
OI_TH     = float(os.getenv("FORWARD_MIN_OIZ",    "1.0"))
MIN_VOL24 = float(os.getenv("FORWARD_MIN_VOL24H", "10000000"))
CONS_N    = int(os.getenv("FORWARD_CONSENSUS_BARS","3"))

# OI (Bybit v5)
OI_WINDOW   = int(os.getenv("FORWARD_OI_WINDOW",   "48"))
OI_INTERVAL =      os.getenv("FORWARD_OI_INTERVAL","5min")
ALLOW_OI_NONE = os.getenv("FORWARD_ALLOW_OI_NONE","false").lower()=="true"

# –°–µ—Ç—å / –æ–ø—Ä–æ—Å / –ª–∏–º–∏—Ç—ã
POLL_SEC  = int(os.getenv("FORWARD_POLL_SEC","8"))
T_CONN    = int(float(os.getenv("FORWARD_TIMEOUT_CONNECT","5")))
T_READ    = int(float(os.getenv("FORWARD_TIMEOUT_READ","30")))
RETRIES   = int(float(os.getenv("FORWARD_MAX_RETRIES","2")))
SLEEP_R   = float(os.getenv("FORWARD_RETRY_SLEEP","1.0"))
SEND_LIM  = int(os.getenv("FORWARD_SEND_LIMIT","3"))
COOLDOWN  = int(os.getenv("FORWARD_COOLDOWN_MIN","30"))*60  # —Å–µ–∫

s = requests.Session()

# –ö—ç—à –Ω–∞–ª–∏—á–∏—è –ª–∏–Ω–µ–π–Ω—ã—Ö —Ñ—å—é—á–µ—Ä—Å–æ–≤ (–æ—Ç—Å–µ—á—ë–º —Å–ø–æ—Ç/–∏–Ω–≤–µ—Ä—Å–Ω—ã–µ)
linear_cache = {}  # sym -> True/False
def has_linear(sym: str) -> bool:
    if sym in linear_cache:
        return linear_cache[sym]
    try:
        r = s.get(
            "https://api.bybit.com/v5/market/instruments-info",
            params={"category":"linear","symbol":sym},
            timeout=(T_CONN, T_READ),
        )
        j = r.json()
        ok = bool(((j.get("result",{}) or {}).get("list",[]) or []))
        linear_cache[sym] = ok
        return ok
    except Exception:
        linear_cache[sym] = False
        return False

def fetch_oi_z(sym: str):
    """–í–µ—Ä–Ω—ë—Ç z-score –ø–æ OI (Bybit linear). None ‚Äî –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –º–∞–ª–æ/–æ—à–∏–±–∫–∞."""
    try:
        r = s.get(
            "https://api.bybit.com/v5/market/open-interest",
            params={"category":"linear","symbol":sym,"interval":OI_INTERVAL},
            timeout=(T_CONN, T_READ),
        )
        j = r.json()
        arr = (j.get("result",{}) or {}).get("list",[]) or []
        vals=[]
        for it in arr:
            v = it.get("openInterest") or it.get("openInterestValue")
            if v is None: continue
            try: vals.append(float(v))
            except: pass
        if len(vals) < 3:
            return None
        series = vals[-OI_WINDOW:] if len(vals)>OI_WINDOW else vals
        mu = sum(series)/len(series)
        var = sum((x-mu)**2 for x in series)/len(series)
        sd = math.sqrt(var) if var>0 else 0.0
        if sd == 0: return 0.0
        return (series[-1]-mu)/sd
    except Exception:
        return None

def fmt_money(x: float) -> str:
    try:
        v = float(x or 0)
        if v >= 1_000_000_000: return f"${v/1_000_000_000:.1f}B"
        if v >= 1_000_000:     return f"${v/1_000_000:.1f}M"
        if v >= 1_000:         return f"${v/1_000:.1f}K"
        return f"${v:.0f}"
    except Exception:
        return str(x)

def build_markup(sym: str):
    tv  = f"https://www.tradingview.com/chart/?symbol=BYBIT:{sym}.P&interval=5"
    bb  = f"https://www.bybit.com/trade/usdt/{sym}"
    return {
        "inline_keyboard": [[
            {"text":"‚ÜóÔ∏è Bybit","url":bb},
            {"text":"‚ÜóÔ∏è TradingView","url":tv},
        ]]
    }

def arrows(z, volx, oi_z):
    def arrow(val, up):
        if val is None: return "‚âà0"
        if val >= up:   return "‚Üë"
        if val <= -up:  return "‚Üì"
        return "‚âà0"
    a_p  = arrow(z,  Z_TH)
    a_v  = "‚Üë" if (volx is not None and volx >= V_TH) else "‚âà0"
    a_oi = arrow(oi_z, OI_TH) if (oi_z is not None or ALLOW_OI_NONE) else "‚âà0"
    # –µ—Å–ª–∏ ALLOW_OI_NONE –∏ oi_z==None ‚Äî —Ç—Ä–∞–∫—Ç—É–µ–º –∫–∞–∫ "‚Üë" (—á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ç–æ–∫)
    if ALLOW_OI_NONE and oi_z is None: a_oi = "‚Üë"
    return a_p, a_v, a_oi

def classify(a_p, a_v, a_oi):
    if a_p=="‚Üë" and a_v=="‚Üë" and a_oi=="‚Üë": return "LONG","üü¢"
    if a_p=="‚Üì" and a_v=="‚Üë" and a_oi=="‚Üë": return "SHORT","üî¥"
    return None, None

def pull_signals():
    for _ in range(1+RETRIES):
        try:
            r = s.get(f"{HOST}/signals", timeout=(T_CONN, T_READ))
            return r.json()
        except Exception:
            time.sleep(SLEEP_R)
    raise RuntimeError("signals: retries exceeded")

seen_bars    = set()  # (sym, bar_ts)
last_sent_at = {}     # sym -> ts
cons_bufs    = {}     # sym -> list[int] (0/1 –ø–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—é z/vx/v24)

def main():
    print(f"forwarder start | host={HOST} Z>={Z_TH} Vx>={V_TH} OIz>={OI_TH} v24h>={MIN_VOL24:.1f} | OI window={OI_WINDOW} interval={OI_INTERVAL} | consensus={CONS_N}x5m", flush=True)
    while True:
        try:
            j = pull_signals()
            data = j.get("data", []) or []
            send_cnt = 0
            loop_sent = set()
            now = int(time.time())

            for sig in data:
                sym    = str(sig.get("symbol","")).upper()
                # Bybit linear-only filter
                if not has_linear(sym):
                    continue
                bar_ts = sig.get("bar_ts")
                key    = (sym, bar_ts)

                # –¢–æ–ª—å–∫–æ –ª–∏–Ω–µ–π–Ω—ã–µ —Ñ—å—é—á–µ—Ä—Å—ã Bybit
                if not has_linear(sym):
                    continue

                # Dedupe –ø–æ –±–∞—Ä—É –∏ –∑–∞ —Ç–∏–∫ –ø–æ —Å–∏–º–≤–æ–ª—É
                if key in seen_bars:    continue
                if sym in loop_sent:    continue

                # Cooldown –ø–æ —Å–∏–º–≤–æ–ª—É
                last = last_sent_at.get(sym, 0)
                if last and now - last < COOLDOWN:
                    continue

                # –ë–∞–∑–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –∏–∑ —è–¥—Ä–∞
                z   = float(sig.get("zprice") or 0.0)
                vx  = float(sig.get("vol_mult") or 0.0)
                v24 = float(sig.get("vol24h_usd") or 0.0)
                px  = sig.get("close")

                # –õ–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å
                if v24 < MIN_VOL24:
                    continue

                # –ö–æ–Ω—Å–µ–Ω—Å—É—Å –ø–æ 5m: –æ–±–Ω–æ–≤–∏–º –±—É—Ñ–µ—Ä (1 –µ—Å–ª–∏ z/vx –ø—Ä–æ—à–ª–∏, –∏–Ω–∞—á–µ 0)
                passed = 1 if (z >= Z_TH and vx >= V_TH) else 0
                buf = cons_bufs.setdefault(sym, [])
                buf.append(passed)
                if len(buf) > CONS_N:
                    buf.pop(0)
                # –¢—Ä–µ–±—É–µ–º, —á—Ç–æ–±—ã –≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö CONS_N –≤—Å–µ –ø—Ä–æ—à–ª–∏
                if len(buf) < CONS_N or sum(buf) < CONS_N:
                    continue

                # OI
                oi_z = fetch_oi_z(sym)
                if not ALLOW_OI_NONE and oi_z is None:
                    # –¢—Ä–µ–±—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π OI ‚Äî –µ—Å–ª–∏ None, —Å–∫–∏–ø–∞–µ–º
                    continue

                # –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è
                a_p, a_v, a_oi = arrows(z, vx, oi_z)
                cls, mark = classify(a_p, a_v, a_oi)
                if cls is None:
                    continue

                # –ê–Ω—Ç–∏—Ñ–ª—É–¥
                if send_cnt >= SEND_LIM:
                    continue

                # –û—Ç–ø—Ä–∞–≤–∫–∞
                seen_bars.add(key)
                loop_sent.add(sym)
                last_sent_at[sym] = now

                oi_str = "‚Äî" if oi_z is None else f"{oi_z:+.2f}"
                text = (
                    f"{mark} {cls} | {sym}\n"
                    f"–¶–µ–Ω–∞: {px}\n"
                    f"P:{a_p} V:{a_v} OI:{a_oi} | z={z:+.2f} vol√ó{vx:.2f} OI z={oi_str}\n"
                    f"–û–±–æ—Ä–æ—Ç 24—á ‚âà {fmt_money(v24)}"
                )

                if TOKEN and CHAT:
                    r = s.post(
                        f"https://api.telegram.org/bot{TOKEN}/sendMessage",
                        json={
                            "chat_id": CHAT,
                            "text": text,
                            "reply_markup": build_markup(sym),
                            "disable_web_page_preview": True
                        },
                        timeout=(T_CONN, T_READ),
                    )
                    try:
                        ok = (r.status_code == 200) and (r.json().get("ok") is True)
                    except Exception:
                        ok = False
                    print(f"sent {sym} {cls} -> http={r.status_code} ok={ok}", flush=True)

                send_cnt += 1

        except Exception as e:
            print("forward err:", e, flush=True)

        time.sleep(max(1, POLL_SEC))

if __name__ == "__main__":
    main()
