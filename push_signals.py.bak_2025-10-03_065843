import os, time, json, requests, statistics
from datetime import datetime

HOST      = os.getenv("HOST", "http://127.0.0.1:8080")
TG_TOKEN  = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT   = os.getenv("TELEGRAM_CHAT_ID")

# –ü–æ—Ä–æ–≥–∏
MIN_Z        = float(os.getenv("FORWARD_MIN_Z",       "2.0"))       # |zprice|
MIN_VOLX     = float(os.getenv("FORWARD_MIN_VOLX",    "1.8"))       # vol√ó
MIN_OI_Z     = float(os.getenv("FORWARD_MIN_OIZ",     "1.0"))       # OI z
MIN_VOL24H   = float(os.getenv("FORWARD_MIN_VOL24H",  "10000000"))  # $10M
POLL_SEC     = int(  os.getenv("FORWARD_POLL_SEC",    "8"))

# –û–∫–Ω–æ/–∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è OI (Bybit)
OI_WINDOW    = int(  os.getenv("FORWARD_OI_WINDOW",   "48"))        # ~4—á –ø—Ä–∏ 5–º
OI_INTERVAL  =        os.getenv("FORWARD_OI_INTERVAL","5min")

# –¢–∞–π–º–∞—É—Ç—ã/—Ä–µ—Ç—Ä–∞–∏
TIMEOUT_CONNECT = int(float(os.getenv("FORWARD_TIMEOUT_CONNECT","5")))
TIMEOUT_READ    = int(float(os.getenv("FORWARD_TIMEOUT_READ","30")))
MAX_RETRIES     = int(float(os.getenv("FORWARD_MAX_RETRIES","3")))
RETRY_SLEEP_SEC = float(os.getenv("FORWARD_RETRY_SLEEP","1.0"))

s     = requests.Session()
seen  = set()   # –∫–ª—é—á —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏: (symbol, bar_ts)

def fmt_money(x):
    try:
        v = float(x or 0)
        if v >= 1_000_000_000: return f"${v/1_000_000_000:.1f}B"
        if v >= 1_000_000:     return f"${v/1_000_000:.1f}M"
        if v >= 1_000:         return f"${v/1_000:.1f}K"
        return f"${v:.0f}"
    except Exception:
        return str(x)

def build_markup(sym: str):
    # –¥–≤–µ –∫–Ω–æ–ø–∫–∏ –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ (–∫–∞–∫ –ø—Ä–æ—Å–∏–ª)
    url_tv    = f"https://www.tradingview.com/chart/?symbol=BYBIT:{sym}.P&interval=5"
    bybit_web = f"https://www.bybit.com/trade/usdt/{sym}"
    return {"inline_keyboard":[
        [{"text":"‚ÜóÔ∏è Open on Bybit","url":bybit_web},
         {"text":"‚ÜóÔ∏è TradingView", "url":url_tv}]
    ]}

def pull_signals():
    last_err = None
    for _ in range(MAX_RETRIES):
        try:
            r = s.get(f"{HOST}/signals", timeout=(TIMEOUT_CONNECT, TIMEOUT_READ))
            return r.json()
        except Exception as e:
            last_err = e
            time.sleep(RETRY_SLEEP_SEC)
    raise RuntimeError(f"/signals retries exceeded: {last_err}")

def fetch_oi_z(sym: str):
    """–í–µ—Ä–Ω—ë—Ç z-score –ø–æ OI (float) –∏–ª–∏ None, –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å/–º–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö."""
    try:
        r = s.get(
            "https://api.bybit.com/v5/market/open-interest",
            params={"category":"linear","symbol":sym,"interval":OI_INTERVAL},
            timeout=(TIMEOUT_CONNECT, TIMEOUT_READ),
        )
        j = r.json()
        arr = (j.get("result",{}) or {}).get("list",[]) or []
        vals = []
        for it in arr:
            v = it.get("openInterest") or it.get("openInterestValue")
            if v is None: 
                continue
            try:
                vals.append(float(v))
            except: 
                pass
        if len(vals) < max(10, OI_WINDOW//2):
            return None
        series = vals[-OI_WINDOW:]
        mu  = sum(series)/len(series)
        var = sum((x-mu)*(x-mu) for x in series)/len(series)
        sd  = var**0.5
        if sd == 0: 
            return 0.0
        z = (series[-1]-mu)/sd
        return float(z)
    except Exception:
        return None

def classify(side_zprice: float, volx: float, v24: float, oi_z):
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ('long'|'short'|'neutral'|None). None ‚Äî –Ω–µ –ø—Ä–æ—Ö–æ–¥ –ø–æ –±–∞–∑–æ–≤—ã–º —Ñ–∏–ª—å—Ç—Ä–∞–º."""
    # –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ —Ü–µ–Ω–µ/–æ–±—ä—ë–º—É/–æ–±–æ—Ä–æ—Ç—É
    if abs(side_zprice) < MIN_Z:            return None
    if (volx or 0) < MIN_VOLX:              return None
    if (v24  or 0) < MIN_VOL24H:            return None

    # –µ—Å–ª–∏ OI z –µ—Å—Ç—å ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–µ–Ω–¥–æ–≤—É—é –ª–æ–≥–∏—á–µ—Å–∫—É—é —Å–≤—è–∑–∫—É, –∏–Ω–∞—á–µ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ
    if oi_z is None:
        return "neutral"
    if oi_z < MIN_OI_Z:
        return "neutral"

    if side_zprice > 0:
        return "long"
    elif side_zprice < 0:
        return "short"
    return "neutral"

def send(sig, side, oi_z):
    sym = str(sig["symbol"]).upper()
    z   = sig.get("zprice")
    vol = sig.get("vol_mult")
    px  = sig.get("close")
    v24 = fmt_money(sig.get("vol24h_usd"))

    color = {"long":"üü¢üìà","short":"üî¥üìâ","neutral":"üü°"}[side]
    oi_text = "‚Äî" if oi_z is None else f"{oi_z:.2f}"

    text = (
        f"{color} {sym}\n"
        f"–¶–µ–Ω–∞ {px}\n"
        f"–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ {z:+.3g}œÉ | –û–±—ä—ë–º √ó{vol:.2g} | OI z={oi_text}\n"
        f"–û–±–æ—Ä–æ—Ç 24—á ‚âà {v24}"
    )

    buttons = build_markup(sym)
    if TG_TOKEN and TG_CHAT:
        try:
            r = s.post(
                f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                json={"chat_id": TG_CHAT, "text": text, "reply_markup": buttons},
                timeout=(TIMEOUT_CONNECT, TIMEOUT_READ),
            )
            if r.status_code != 200:
                print(f"send error {sym}: {r.status_code} {r.text[:180]}", flush=True)
        except Exception as e:
            print("send exception:", e, flush=True)

def main_loop():
    print(
        f"forwarder start | host={HOST} z>={MIN_Z} volx>={MIN_VOLX} oiz>={MIN_OI_Z} "
        f"v24h>={MIN_VOL24H} | OI window={OI_WINDOW} interval={OI_INTERVAL}",
        flush=True
    )
    while True:
        try:
            j = pull_signals()
            for sig in j.get("data", []):
                key = (sig.get("symbol"), sig.get("bar_ts"))
                if key in seen:
                    continue
                seen.add(key)

                z   = float(sig.get("zprice")   or 0.0)
                vol = float(sig.get("vol_mult") or 0.0)
                v24 = float(sig.get("vol24h_usd") or 0.0)

                oi_z = fetch_oi_z(str(sig.get("symbol","")).upper())
                side = classify(z, vol, v24, oi_z)
                if side is None:
                    continue  # –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –Ω–µ –ø—Ä–æ—à—ë–ª
                send(sig, side, oi_z)
        except Exception as e:
            print("forward err:", e, flush=True)
        time.sleep(max(1, POLL_SEC))

if __name__ == "__main__":
    main_loop()
